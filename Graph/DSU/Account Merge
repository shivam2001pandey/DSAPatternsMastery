emailToIndex → converts emails to DSU indices.
dsu.Union() → connects emails in the same account.
Find() → gives the representative email of the connected component.
components → collects all emails in the same group.
Sorting → required because problem asks emails in lexicographical order

https://leetcode.com/problems/accounts-merge/editorial/

class DSU{
    public:
    vector<int> parent;
    vector<int> size;
    DSU(int s){
        parent.resize(s);
        size.resize(s);

        // can make a seperate function Make()
        for(int i=0;i<s;i++)
        {
            parent[i] = i;
            size[i] = 1;
        }
    }
public:
    int find(int n){
        if(n==parent[n]) return n;
        return parent[n] = find(parent[n]);
    }

    void unite(int a, int b){
        a = find(a);
        b = find(b);
        if(a!=b){
            if(size[a] < size[b])
            {
                swap(a,b);
            }
            parent[b]=a;
            size[a]+= size[b];
        }
    }

    

    
};
class Solution {
public:
    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
        int n = accounts.size();

        

        // STEP 1: assign node number to each email so that DSU can work with int
        unordered_map<string,int> emailToIndex;
        unordered_map<string,string> emailToName;
        int index=0;
        for(int i=0;i<n;i++){
            {
                int m = accounts[i].size();
            for(int j=1;j<m;j++){
                if(emailToIndex.find(accounts[i][j])==emailToIndex.end())
                    emailToIndex[accounts[i][j]] = index++;
                emailToName[accounts[i][j]] = accounts[i][0];
            }
        }
        }

        DSU dsu(index);
        // STEP 2: Perform union
        for(int i=0;i<n;i++)
        {
            int m = accounts[i].size();
            int firstEmailIndex = emailToIndex[accounts[i][1]];
            for(int j=2;j<m;j++){
                dsu.unite(firstEmailIndex, emailToIndex[accounts[i][j]] );
            }
        }

        //STEP 3: Group based on parent
        unordered_map<int, vector<string>> components;
        for (auto& [email, index] : emailToIndex) {
            int root = dsu.find(index);
            components[root].push_back(email);
        }

        // Step 4: Build answer
        vector<vector<string>> result;
        for (auto& [root, emails] : components) {
            sort(emails.begin(), emails.end());
            vector<string> merged;
            merged.push_back(emailToName[emails[0]]);
            merged.insert(merged.end(), emails.begin(), emails.end());
            result.push_back(merged);
        }

        return result;



    }
};

